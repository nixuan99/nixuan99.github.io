{"meta":{"title":"厄夜未央Blog","subtitle":"厄夜未央","description":"咫尺天涯\t莫失莫忘","author":"不系之舟","url":"https://github.com/nixuan99/nixuan99.github.io","root":"/"},"pages":[{"title":"404","date":"2021-11-03T16:00:00.000Z","updated":"2021-11-04T01:58:34.933Z","comments":true,"path":"404.html","permalink":"https://github.com/nixuan99/nixuan99.github.io/404.html","excerpt":"","text":""},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/index.html","permalink":"https://github.com/nixuan99/nixuan99.github.io/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"","date":"2021-11-04T01:08:14.226Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"https://github.com/nixuan99/nixuan99.github.io/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"","date":"2021-11-04T01:08:14.245Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"https://github.com/nixuan99/nixuan99.github.io/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"about","date":"2021-11-03T16:00:00.000Z","updated":"2021-11-04T07:51:58.213Z","comments":true,"path":"about/index.html","permalink":"https://github.com/nixuan99/nixuan99.github.io/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"archives/index.html","permalink":"https://github.com/nixuan99/nixuan99.github.io/archives/index.html","excerpt":"","text":""},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"census/index.html","permalink":"https://github.com/nixuan99/nixuan99.github.io/census/index.html","excerpt":"","text":""},{"title":"留言板","date":"2021-11-03T16:00:00.000Z","updated":"2021-11-04T01:59:57.462Z","comments":true,"path":"contact/index.html","permalink":"https://github.com/nixuan99/nixuan99.github.io/contact/index.html","excerpt":"","text":"评论区在这里可以留下你的足迹，欢迎在下方留言，一起交流学习！ 友情链接 厄夜未央○友链信息 博客名称: 厄夜未央○博客 博客网址: https://nixuan99.github.io 博客介绍: 一个人需要隐藏多少秘密，才能巧妙的度过一生。"},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"categories/index.html","permalink":"https://github.com/nixuan99/nixuan99.github.io/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"friends/index.html","permalink":"https://github.com/nixuan99/nixuan99.github.io/friends/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"resource/index.html","permalink":"https://github.com/nixuan99/nixuan99.github.io/resource/index.html","excerpt":"","text":""},{"title":"相册","date":"2021-11-04T01:08:14.024Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/index.html","permalink":"https://github.com/nixuan99/nixuan99.github.io/List/galleries/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"tags/index.html","permalink":"https://github.com/nixuan99/nixuan99.github.io/tags/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/movies/index.html","permalink":"https://github.com/nixuan99/nixuan99.github.io/List/movies/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/music/index.html","permalink":"https://github.com/nixuan99/nixuan99.github.io/List/music/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/tools/index.html","permalink":"https://github.com/nixuan99/nixuan99.github.io/List/tools/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2021-11-04T01:08:14.027Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"https://github.com/nixuan99/nixuan99.github.io/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2021-11-04T01:08:14.031Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"https://github.com/nixuan99/nixuan99.github.io/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2021-11-04T01:08:14.034Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"https://github.com/nixuan99/nixuan99.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2021-11-04T01:08:14.040Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"https://github.com/nixuan99/nixuan99.github.io/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2021-11-04T01:08:14.045Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"https://github.com/nixuan99/nixuan99.github.io/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2021-11-04T01:08:14.037Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"https://github.com/nixuan99/nixuan99.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2021-11-04T01:08:14.035Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"https://github.com/nixuan99/nixuan99.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2021-11-04T01:08:14.042Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"https://github.com/nixuan99/nixuan99.github.io/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2021-11-04T01:08:14.048Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"https://github.com/nixuan99/nixuan99.github.io/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2021-11-04T01:08:14.065Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"https://github.com/nixuan99/nixuan99.github.io/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2021-11-04T01:08:14.051Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"https://github.com/nixuan99/nixuan99.github.io/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2021-11-04T01:08:14.069Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"https://github.com/nixuan99/nixuan99.github.io/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""}],"posts":[{"title":"CAS和volatile","slug":"关于CAS","date":"2021-11-08T03:56:02.000Z","updated":"2021-11-08T03:58:28.824Z","comments":true,"path":"posts/4fae8c8a.html","link":"","permalink":"https://github.com/nixuan99/nixuan99.github.io/posts/4fae8c8a.html","excerpt":"","text":"CAS 与 volatileCAS前面看到的 AtomicInteger 的解决方法，内部并没有用锁来保护共享变量的线程安全。那么它是如何实现的呢？ public void withdraw(Integer amount) { while(true) { // 需要不断尝试，直到成功为止 while (true) { // 比如拿到了旧值 1000 int prev = balance.get(); // 在这个基础上 1000-10 = 990 int next = prev - amount; /* compareAndSet 正是做这个检查，在 set 前，先比较 prev 与当前值1000 - 不一致了，next 作废，返回 false 表示失败 比如，别的线程已经做了减法，当前值已经被减成了 990 那么本线程的这次 990 就作废了，进入 while 下次循环重试 - 一致，以 next 设置为新值，返回 true 表示成功 */ if (balance.compareAndSet(prev, next)) { break; } } } } ​ ​ 其中的关键是 compareAndSet，它的简称就是CAS（也有 Compare And Swap 的说法），它必须是原子操作。 注意其实 CAS 的底层是 lock cmpxchg 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交换】的原子性。 在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。 volatile获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。 ​ 它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存。 ​ 即一个线程对volatile变量的修改，对另一个线程可见。 注意：volatile 仅仅保证了共享变量的可见性，让其它线程能够看到最新值，但不能解决指令交错问题，不能保证原子性。 CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果 为什么无锁效率高 无锁情况下，即使一直在while循环，重试失败，线程始终在高速运行，没有停歇。而 synchronized 会让线程在没有获得锁的时候，发生上下文切换，进入阻塞。 打个比喻，线程就好像高速跑道上的赛车，高速运行时，速度超快，一旦发生上下文切换，就好比赛车要减速、熄火，等被唤醒又得重新打火、启动、加速… 恢复到高速运行，代价比较大。 但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还是会导致上下文切换。 CAS情况下，必须是多核CPU才能发挥优势，线程数少于CPU核心数用CAS是非常合适的。 CAS 的特点结合 CAS 和 volatile 可以实现无锁并发，适用于线程数少、多核 CPU 的场景下。 CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。 synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。 CAS 体现的是无锁并发、无阻塞并发，请仔细体会这两句话的意思 因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一 但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响","categories":[],"tags":[{"name":"JUC多线程","slug":"JUC多线程","permalink":"https://github.com/nixuan99/nixuan99.github.io/tags/JUC%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"Java创建线程的方式","slug":"Java创建线程的方式","date":"2021-11-04T08:08:47.000Z","updated":"2021-11-04T08:09:29.602Z","comments":true,"path":"posts/be2f9984.html","link":"","permalink":"https://github.com/nixuan99/nixuan99.github.io/posts/be2f9984.html","excerpt":"","text":"创建和运行线程方法一，直接使用 Threadpackage cn.itcast.test; import lombok.extern.slf4j.Slf4j; /** * @Author 厄夜未央 * @Date 2021/10/8 19:12 */ @Slf4j(topic = \"c.Test1\") public class Test1 { public static void main(String[] args) { //创建线程,使用匿名内部类 //这里是多态，创建的new Thread() 是子类 Thread t = new Thread(){ @Override public void run() { log.debug(\"running\"); } }; //定义名字 t.setName(\"不系之舟\"); //启动线程 t.start(); //main方法主线程 log.debug(\"main running\"); } } 方法二，使用 Runnable 配合 Thread（推荐）把【线程】和【任务】（要执行的代码）分开，Thread 代表线程，Runnable 可运行的任务（线程要执行的代码）。 package cn.itcast.test; import lombok.extern.slf4j.Slf4j; /** * @Author 厄夜未央 * @Date 2021/10/8 19:31 */ @Slf4j(topic = \"c.Test2\") public class Test2 { public static void main(String[] args) { Runnable r = new Runnable() { @Override public void run() { log.debug(\"任务对象线程\"); } }; //创建线程 Thread t = new Thread(r,\"不系之舟\"); t.start(); } } lambda表达式 package cn.itcast.test; import lombok.extern.slf4j.Slf4j; /** * @Author 厄夜未央 * @Date 2021/10/8 19:31 */ @Slf4j(topic = \"c.Test2\") public class Test2 { public static void main(String[] args) { // 使用 lambda 表达式，因为 Runnable 接口 // 标注了 @FunctionalInterface 这个注解，表示是一个函数式接口，可以使用 lambda 表达式 Runnable r = () -&gt; log.debug(\"任务对象线程\"); //创建线程 Thread t = new Thread(r,\"不系之舟\"); t.start(); } } 方法三，FutureTask 配合 Thread​ FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况 package cn.itcast.test; import lombok.extern.slf4j.Slf4j; import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.FutureTask; /** * @Author 厄夜未央 * @Date 2021/10/8 20:41 */ @Slf4j(topic = \"c.Test3\") public class Test { public static void main(String[] args) throws ExecutionException, InterruptedException { //创建任务对象 FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;(new Callable&lt;Integer&gt;() { @Override public Integer call() throws Exception { log.debug(\"任务对象执行\"); Thread.sleep(3000); return 1000; } }); Thread t = new Thread(task); t.start(); // task.get() 等任务对象返回结果后打印返回值，在主线程中执行的 log.debug(\"{}\",task.get()); // ”{}“ 表示占位符 } } 方法一： 子类继承Thread，直接使用Thread Thread t = new Thread(); 这是多态，创建了子类对象。 创建了Thread的子类对象，在子类对象中重写了 Thread中的run() 方法，最终还是执行了 子类的 run() 方法 方法二 原理之 Thread 与 Runnable 的关系 Thread中有一个 init() 方法，在方法中把 Runnable对象赋值给了 Thread 的成员变量 target 这个Runnbale是在 Thread中 run() 方法中用到的，在方法中判断这个 Runnable不为空，然后调用这个Runnable的 run() 方法 实际上调用的还是Thread的 run() 方法 在 Thread 中如果发现有 Runnable 对象，就会优先采用 Runnable对象的 run() 方法 小结： 方法1 是把线程和任务合并在了一起，方法2 是把线程和任务分开了 用 Runnable 更容易与线程池等高级 API 配合 用 Runnable 让任务类脱离了 Thread 继承体系，更灵活 方法三，FutureTask 配合 Thread FutureTask 实现了 RunnableFuture 接口，这个接口继承了 Runnable，所以说FutrueTak间接实现了Runnable接口 FutureTask 需要配合callable接口来实现任务，callable可以抛出异常 因为FutureTask也实现了Runnable接口，所以可以传入 Thread的构造方法","categories":[],"tags":[]},{"title":"我的第一篇博客文章","slug":"我的第一篇博客文章","date":"2021-11-04T00:38:26.000Z","updated":"2021-11-04T01:21:26.107Z","comments":true,"path":"posts/b24dd347.html","link":"","permalink":"https://github.com/nixuan99/nixuan99.github.io/posts/b24dd347.html","excerpt":"","text":"第一章Hello World 第二章你好，世界！ 第三章厄夜未央","categories":[],"tags":[{"name":"first blog","slug":"first-blog","permalink":"https://github.com/nixuan99/nixuan99.github.io/tags/first-blog/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-11-04T00:34:13.086Z","updated":"2021-11-04T01:21:26.108Z","comments":true,"path":"posts/4a17b156.html","link":"","permalink":"https://github.com/nixuan99/nixuan99.github.io/posts/4a17b156.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"JUC多线程","slug":"JUC多线程","permalink":"https://github.com/nixuan99/nixuan99.github.io/tags/JUC%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"first blog","slug":"first-blog","permalink":"https://github.com/nixuan99/nixuan99.github.io/tags/first-blog/"}]}